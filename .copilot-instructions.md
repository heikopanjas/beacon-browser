# BLEScanner - Copilot Instructions

## Project Overview
BLEScanner is a Swift command-line tool for scanning and analyzing Bluetooth Low Energy (BLE) devices. It provides detailed information about discovered devices including manufacturer data, signal strength, and device-specific parsing for major manufacturers.

**Repository**: https://github.com/ultralove/beacon-browser

## Architecture & Technologies
- **Language**: Swift 6.1+
- **Framework**: Swift Package Manager (SPM)
- **Dependencies**:
  - Swift Argument Parser 1.2.0+ for CLI interface
  - CoreBluetooth for BLE functionality
- **Platform**: macOS (requires Bluetooth LE support)
- **Repository**: GitHub origin remote configured (SSH)

## Project Structure
```
BLEScanner/
├── Package.swift                 # Swift Package Manager configuration
├── Package.resolved             # Dependency lock file
├── Sources/
│   └── BLEScanner.swift         # Main application code
├── .build/                      # Build artifacts (auto-generated)
└── .vscode/                     # VS Code configuration
```

## Core Components

### Scanner Class
- **Purpose**: Main BLE scanning implementation
- **Responsibilities**:
  - CoreBluetooth central manager delegate
  - Device discovery and advertisement data parsing
  - Signal quality analysis and distance estimation
  - Manufacturer-specific data interpretation

### Manufacturer Data Parsing
The tool includes specialized parsers for:
- **Apple**: iBeacon, AirPods, Handoff/Continuity, Nearby/AirDrop
- **Microsoft**: CDP (Cross Device Protocol), Surface devices
- **Samsung**: Device-specific data structures
- **Nordic Semiconductor**: Development/test devices
- **Govee**: Smart home devices (LED strips, sensors)
- **Generic**: Unknown manufacturers with pattern detection

### Signal Analysis
- RSSI-based signal quality assessment (Excellent to Barely Detectable)
- Distance estimation based on signal strength
- TX Power level reporting when available

## Development Guidelines

### Code Style
- Follow Swift naming conventions (camelCase, PascalCase for types)
- Use meaningful variable and function names
- Prefer explicit types when clarity is improved
- Use guard statements for early returns
- Implement proper error handling

### Documentation Style
- Write clear, professional documentation without emojis
- Use plain text formatting and descriptive language
- Focus on technical accuracy and readability
- Maintain consistent formatting throughout all documentation

### Adding New Manufacturer Support
1. Add company identifier to the `companies` dictionary in `getManufacturerName()`
2. Add case to the switch statement in `parseManufacturerSpecificData()`
3. Implement dedicated parsing function following pattern: `parse{Company}ManufacturerData()`
4. Include detailed comments about data structure interpretation

### Data Analysis Patterns
- Use hexdump for raw data visualization
- Implement structured parsing with field-by-field analysis
- Provide meaningful interpretations of numeric values
- Include ASCII representation when applicable
- Add context about device capabilities and expected behavior

### Testing Considerations
- Test with real BLE devices when possible
- Verify manufacturer data parsing accuracy
- Test signal strength calculations across different distances
- Validate edge cases (empty data, incomplete packets)

### Git Commit Guidelines
When the user asks to commit changes, follow this automated workflow:

#### Automated Commit Process
**MANDATORY WORKFLOW**: When user requests to commit latest changes:

1. **Check repository status**: First examine current git status to understand what has changed
2. **Stage all changes**: Use `git add .` to stage all modified, new, and deleted files
3. **Analyze changes**: Review staged changes to understand the scope and nature of modifications
4. **Generate commit message**: Create detailed but concise commit messages using conventional commits format
5. **Execute commit**: Run `git commit -m "<generated-message>"` with the crafted message
6. **Update instructions**: Always update this `.copilot-instructions.md` file after significant project changes
7. **Confirm completion**: Report successful commit with hash and summary to user

#### Conventional Commit Format
Use these prefixes based on change type:
- `feat:` for new features (e.g., new manufacturer support, CLI options, new scanning capabilities)
- `fix:` for bug fixes (e.g., parsing errors, memory leaks, incorrect data interpretation)
- `docs:` for documentation updates (e.g., README changes, code comments, instruction updates)
- `refactor:` for code refactoring (e.g., function reorganization, performance improvements, code cleanup)
- `test:` for adding or modifying tests (e.g., new test cases, test infrastructure)
- `chore:` for maintenance tasks (e.g., dependency updates, build configuration, tooling)
- `style:` for code style changes (formatting, missing semicolons, linting fixes)
- `perf:` for performance improvements (optimization, memory usage, speed enhancements)
- `ci:` for CI/CD configuration changes
- `build:` for build system changes
- `revert:` for reverting previous commits

#### Commit Message Structure
```
<type>(<scope>): <description>

[optional body explaining what and why, not how]

[optional footer(s) with breaking changes, closes issues, etc.]
```

#### Scope Guidelines
Use meaningful scopes to categorize changes:
- `parser`: manufacturer data parsing logic
- `scanner`: BLE scanning and device discovery
- `signal`: RSSI analysis and distance estimation
- `cli`: command-line interface and argument handling
- `docs`: documentation and instruction files
- `deps`: dependency management
- `config`: project configuration files

#### Commit Message Examples
- `feat(parser): add support for Xiaomi device manufacturer data parsing`
- `fix(scanner): resolve CoreBluetooth memory leak in delegate callbacks`
- `docs: update copilot instructions with automated git workflow`
- `refactor(signal): improve RSSI distance calculation accuracy and add calibration`
- `chore(deps): update Swift Argument Parser to version 1.3.0`
- `perf(parser): optimize manufacturer data lookup with hash table implementation`
- `style(scanner): apply Swift formatting conventions and fix linting warnings`

#### Automated Workflow Triggers
Respond to these user requests with the automated workflow:
- "commit the latest changes"
- "commit these changes"
- "stage and commit"
- "make a commit"
- "commit this work"
- "git commit with message"

#### Pre-commit Checklist
Before executing commits, ensure:
- [ ] Code compiles without errors or warnings
- [ ] All new functionality is properly documented
- [ ] Manufacturer data parsing follows established patterns
- [ ] Signal analysis calculations are accurate
- [ ] Privacy and security considerations are maintained
- [ ] Performance impact is acceptable

## Build & Run Instructions

### Development
```bash
swift build
swift run
```

### Release Build
```bash
swift build -c release
```

### Dependencies Update
```bash
swift package update
```

## CLI Usage
The tool starts scanning immediately and displays detailed information about discovered BLE devices. Use Ctrl+C to stop scanning gracefully.

## Data Structure Notes

### Advertisement Data Keys
- `CBAdvertisementDataLocalNameKey`: Device local name
- `CBAdvertisementDataManufacturerDataKey`: Manufacturer-specific data
- `CBAdvertisementDataServiceUUIDsKey`: Advertised service UUIDs
- `CBAdvertisementDataServiceDataKey`: Service-specific data
- `CBAdvertisementDataTxPowerLevelKey`: Transmission power level
- `CBAdvertisementDataIsConnectable`: Connection capability
- `CBAdvertisementDataSolicitedServiceUUIIDsKey`: Requested services
- `CBAdvertisementDataOverflowServiceUUIDsKey`: Additional services

### Common Manufacturer Data Formats
- **Company ID**: First 2 bytes (little-endian)
- **Apple iBeacon**: 23 bytes total (UUID + Major + Minor + TX Power)
- **Govee Devices**: Status/config data with device type identification
- **Nordic**: Development device type and version information

## Future Enhancement Ideas
- Add support for connecting to discovered devices
- Implement service and characteristic exploration
- Add filtering options (by manufacturer, signal strength, etc.)
- Create output formats (JSON, CSV) for data analysis
- Add device tracking and change detection over time
- Implement manufacturer data decoding for additional companies

## Security & Privacy Notes
- Tool only scans advertising data (passive monitoring)
- No device connections are established by default
- Respects BLE privacy features and MAC address randomization
- Consider privacy implications when logging device identifiers

## Troubleshooting
- Ensure Bluetooth is enabled and powered on
- Check macOS privacy settings for Bluetooth access
- Verify device is in advertising mode for testing
- Some devices may use randomized MAC addresses
- Signal strength varies with environment and obstacles

---
*This file should be updated as the project evolves and new features are added.*
